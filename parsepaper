#!/usr/bin/ruby
#parsepaper.rb

require 'optparse'


class ParseArguments < Hash
  def initialize(args)
    super()
    self[:commit_message] = ''
    self[:mode] = :status
    self[:ticket_numbers] = nil
    self[:taskpaper_file] = 'todo.taskpaper'

    self[:possible_modes] = [:decorate, :commit, :status, :auto]

    opts = OptionParser.new do |opts|
      opts.banner = "Usage: #$0 (decorate|commit|status|auto) [options]\
      decorate: add ticket numbers to the taskpaper file
      commit: take all tasks that are @done and commit them
      status: show what would be commited
      auto: first decorate the file, then if something is done, commit it."

      opts.on('-m', '--message [STRING]', 'add commit message [STRING]') do |string|
        self[:commit_message] = string || ""
      end

      opts.on('-t', '--tickets x,y,z', 'list of tickets to commit') do |list|
        self[:ticket_numbers] = list.collect{ |ticket| 
          if ticket[0]=='#':
            return ticket
          end
        }
      end

      opts.on('-f', '--taskpaper [TASKPAPERFILE]', 'chose a custom taskpaper file. default is todo.taskpaper') do |string|
        self[:taskpaper_file] = string 
      end

      opts.on('-h', '--help', 'display this help and exit') do
        puts opts
        exit
      end

    end

    #first, parse the arguments
    opts.parse!(args)

    #check if the actual mode is known
    if args.size>1
      puts "Please provide only one mode"
      exit
    end

    if args.size==0
      puts "Please provide a mode"
      exit
    end
    mode = args.first

    if self[:possible_modes].index(mode.to_sym).nil?
        puts "Unknown mode #{mode}"
        exit
    end
    self[:mode] = mode.to_sym
 end
end

class Task
  #get information about this line, i.e. is it done, does it have a ticket, etc
  attr_accessor :ticket
  attr_accessor :line
  attr_accessor :done
  alias_method :done?, :done
  attr_accessor :whitespace
  alias_method :whitespace?, :whitespace
  attr_accessor :project
  alias_method :project?, :project
  def initialize(line)
    @line = line.strip
    @ticket = nil
    if /\#[0-9]{1,4}/.match(@line)
      @ticket = /\#([0-9]{1,4})/.match(@line)[1]
      # and remove the ticket from the line. we will add it again later on
      # this means that tickes are always at the end of the line, which is
      # expected behaviour / a feature
      @line.gsub!(/\ ?\#([0-9]{1,4})/, "")
    end
    @done =  !/\@done/.match(@line).nil?

    @project = false
    if @line[-1,1]==":"
      @project = true
    end

    @whitespace = false
    if @line.size<=1
      @whitespace = true
    end
  end

  def decoratedLine
    #decorate the line with the ticket
    if @ticket.nil?
      return @line
    else
      return "#{@line} \##{@ticket}"
    end
  end

  def ticket?
    return @ticket!=nil
  end

end

class Parsepaper
    def initialize(arguments)
        @args = arguments


        # Check if the taskpaper_file exists.
        if !File.file? @args[:taskpaper_file]
          puts "Couldn't find #{@args[:taskpaper_file]}"
          exit
        end

        # Read the file, fill the ticket numbers, create the dict, and the array
        @lines = []
        #this contains all the tickets in the file, so we don't issue a ticket twice
        @tickets = {}

        open(@args[:taskpaper_file]).each{ |line|
          #if the line just contains whitespace or just a -, just add it
          taskInstance = Task.new(line)
          if taskInstance.ticket?
            @tickets[taskInstance.ticket] = taskInstance
          end
          @lines << taskInstance
        }

        #and see what we should do...
        if not self.respond_to?(@args[:mode].to_s)
          puts "Unknown action: " << @args[:mode].to_s
        end
    end

    def run
        self.send(@args[:mode].to_s)
    end

    #generate a ticket
    def generateTicket
      #tickets have 4 numbers
      begin
        number = "#{rand(9999)}"
      end while not @tickets.index(number).nil?
      return number.strip
    end

    #generate an array of all changes that would be commited
    def arrayOfChanges
      #we could also use Ruby/Git here, but that feels like an overkill right #now.
      gitChanges = `git diff #{@args[:taskpaper_file]} | grep '^\+' | grep -i '\@done'`
      puts gitChanges.split("\n")
    end

    def save
      #and write the outputlines back into the file.
      open(@args[:taskpaper_file], 'w') do |file|
        @lines.each{ |taskInstance| file << taskInstance.decoratedLine << "\n" } 
      end
    end

    def decorate
      # Run through the file, one line at a time, and decorate it, if
      @lines.each{ |ti|
        if !ti.whitespace? and !ti.project? and !ti.done? and !ti.ticket?
          ticket = self.generateTicket
          ti.ticket = ticket
          @tickets[ti.ticket] = ti
        end
      }
      self.save
    end

    def status
      self.arrayOfChanges
    end

    def commit

    end
end


#and run it

args = ParseArguments.new(ARGV)

parsePaper = Parsepaper.new(args)
parsePaper.run

